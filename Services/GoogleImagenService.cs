using System.Drawing;
using System.Drawing.Imaging;
using System.Text;
using System.Text.Json;

namespace WallTrek.Services
{
    public class GoogleImagenService : IImageGenerationService
    {
        private readonly string apiKey;
        private readonly string outputDirectory;
        private readonly DatabaseService databaseService;
        private readonly HttpClient httpClient;
        private const string ModelId = "models/imagen-4.0-ultra-generate-001";
        private const string BaseUrl = "https://generativelanguage.googleapis.com/v1beta";

        public GoogleImagenService(string apiKey, string outputDirectory)
        {
            this.apiKey = apiKey ?? throw new ArgumentNullException(nameof(apiKey));
            this.outputDirectory = outputDirectory ?? throw new ArgumentNullException(nameof(outputDirectory));
            this.databaseService = new DatabaseService();
            this.httpClient = new HttpClient();
        }

        public async Task<string> GenerateAndSaveImage(string prompt, string llmModel, string imgModel, CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrEmpty(llmModel))
                throw new ArgumentException("LLM model cannot be null or empty", nameof(llmModel));
            if (string.IsNullOrEmpty(imgModel))
                throw new ArgumentException("Image model cannot be null or empty", nameof(imgModel));
            const int maxFileNamePromptLength = 75;
            var sanitizedPrompt = string.Join("_", prompt.Split(Path.GetInvalidFileNameChars()));
            if (sanitizedPrompt.Length > maxFileNamePromptLength)
            {
                sanitizedPrompt = sanitizedPrompt.Substring(0, maxFileNamePromptLength);
            }

            // Create request payload
            var requestPayload = new
            {
                instances = new[]
                {
                    new { prompt = prompt }
                },
                parameters = new
                {
                    outputMimeType = "image/jpeg",
                    sampleCount = 1,
                    personGeneration = "ALLOW_ALL",
                    aspectRatio = "16:9",
                    imageSize = "2K"
                }
            };

            var jsonContent = JsonSerializer.Serialize(requestPayload);
            var content = new StringContent(jsonContent, Encoding.UTF8, "application/json");

            // Make API request
            var url = $"{BaseUrl}/{ModelId}:predict?key={apiKey}";
            var response = await httpClient.PostAsync(url, content, cancellationToken);

            if (!response.IsSuccessStatusCode)
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                throw new InvalidOperationException($"Google Imagen API request failed: {response.StatusCode} - {errorContent}");
            }

            var responseContent = await response.Content.ReadAsStringAsync();
            
            // Parse response to extract base64 image data
            using var jsonDoc = JsonDocument.Parse(responseContent);
            var predictions = jsonDoc.RootElement.GetProperty("predictions");
            
            if (predictions.GetArrayLength() == 0)
            {
                throw new InvalidOperationException("No images were generated by Google Imagen");
            }

            var firstPrediction = predictions[0];
            if (!firstPrediction.TryGetProperty("bytesBase64Encoded", out var base64Element))
            {
                throw new InvalidOperationException("No image data found in response");
            }

            var base64Data = base64Element.GetString();
            if (string.IsNullOrEmpty(base64Data))
            {
                throw new InvalidOperationException("Empty image data received");
            }

            // Decode base64 image data
            var imageBytes = Convert.FromBase64String(base64Data);

            // Create filename and save image
            var fileName = $"{DateTime.Now:yyyy-MM-dd_HH-mm-ss} ({sanitizedPrompt}).jpg";
            var filePath = Path.Combine(outputDirectory, fileName);

            // Save the image with metadata
            using (var memoryStream = new MemoryStream(imageBytes))
            {
                using (var bitmap = new Bitmap(memoryStream))
                {
                    // Add prompt to image metadata
                    var propertyItem = (PropertyItem?)Activator.CreateInstance(typeof(PropertyItem), true);
                    if (propertyItem != null)
                    {
                        propertyItem.Id = 0x010E; // ImageDescription EXIF tag
                        propertyItem.Type = 2; // ASCII string
                        var promptBytes = Encoding.UTF8.GetBytes(prompt + "\0");
                        propertyItem.Value = promptBytes;
                        propertyItem.Len = promptBytes.Length;
                        
                        bitmap.SetPropertyItem(propertyItem);
                    }
                    bitmap.Save(filePath, ImageFormat.Jpeg);
                }
            }

            // Add to database after successful generation
            try
            {
                var promptId = await databaseService.AddOrUpdatePromptAsync(prompt);
                await databaseService.AddGeneratedImageAsync(promptId, filePath, llmModel, imgModel);
            }
            catch (Exception ex)
            {
                // Log database error but don't fail the image generation
                System.Diagnostics.Debug.WriteLine($"Database error: {ex.Message}");
            }

            return filePath;
        }

        public void Dispose()
        {
            httpClient?.Dispose();
        }
    }
}